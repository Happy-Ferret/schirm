<!--
Schirm - a linux compatible terminal emulator providing html modes.
Copyright (C) 2011  Erik Soehnel

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
pre {
    margin: 0px;
    padding: 1px 1px 4px 1px;
}

iframe {
    border: None;
}

#term {
    overflow-x:hidden;
    width: 100%;
}

#app {
    display: none;
    width: 100%;
}

body {
    position:absolute;
    margin:0px;
    border:0px;
    padding:0px;
    top:1px;
    bottom:1px;
    left:1px;
    right:1px;
}
// poor man's templating system:
//TERM-CSS-PLACEHOLDER

</style>

<script type="text/javascript">

// Return the size of a single character in the given PRE element
function getCharSize(preElement) {
  var specimen = document.createElement("span");
  specimen.innerHTML = "x";
  preElement.appendChild(specimen);
  var size = {width: specimen.offsetWidth, height: specimen.offsetHeight};
  preElement.removeChild(specimen);
  return size;
}

// Return the size in lines and columns
function getTermSize(preElement) {
  var blockSize = getCharSize(preElement);
  var cols  = Math.floor(document.body.clientWidth/blockSize.width);
  var lines = Math.floor(document.body.clientHeight/blockSize.height);
  //console.log("resized to [lines, cols]: [" + lines + " ," + cols + "]");
  return { lines: lines, cols: cols };
}

function resizeIframe(iframe) {
  try {
    var doc = iframe.contentDocument.documentElement;
      if (doc) {
        iframe.height = doc.scrollHeight;

        // scrollHeight doesn't include the height of the horizontal
        // scrollbar -> an additional vertical scrollbar appears to
        // still be able to see the whole content (we only want the
        // vertical scrollbar).  therefor: compare to the
        // clientHeight and then adjust the iframe height.
        var rect = doc.getBoundingClientRect();
        if (doc.scrollHeight && doc.clientHeight && doc.scrollHeight > doc.clientHeight) {
          var diff = doc.scrollHeight - doc.clientHeight;
          iframe.height = doc.scrollHeight + diff;
        }
      }
  } catch (e) { }
};

// rendering the terminal in normal mode
// linesElement:
// a PRE element holding the terminals lines
// each line is a span of nested spans for styles
var Lines = (function(linesElement, term) {

  var fn = {

    init: function() {
      // var lines = 25;
      // linesElement.innerHTML = "";
      // for (var i=0; i<lines; i++) {
      //    var span = document.createElement("span");
      //    linesElement.appendChild(span);
      // }
    },

    show: function(enable) {
      linesElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      if (linesElement.childNodes.length < term.size.lines) {
        return lineNumber;
      } else {
        return linesElement.childNodes.length - term.size.lines + lineNumber;
      }
    },

    scrollToBottom: function() {
      linesElement.scrollTop = linesElement.scrollHeight;
    },

    scrollPageUp: function() {
      linesElement.scrollTop -= linesElement.offsetHeight;
    },

    scrollPageDown: function() {
      linesElement.scrollTop += linesElement.offsetHeight;
    },

    lazyLinesInit: function(linenumber) {
      // ensure that all lines up to linenumber exist
      if (linesElement.childNodes.length < term.size.lines) {
        var missingLines = 1 + linenumber - linesElement.childNodes.length;
        console.log("missing lines: " + missingLines);
        if (missingLines > 0) {
          for (var i=0; i<missingLines; i++) {
            var span = document.createElement("span");
            span.innerHTML = "\n";
            linesElement.appendChild(span);
          }
        }
      }
    },

    setTrailingSpace: function(visibleLinesStart, visibleLinesEnd) {
      var filler = document.getElementById("termTrailingSpace");
      var linesHeight = 0;
      for (var i=visibleLinesStart; i<=visibleLinesEnd; i++) {
        linesHeight += linesElement.childNodes[i].height;
      }
      var fillHeight = document.body.clientHeight - linesHeight;
      console.log("linesHeight: " + linesHeight + " fillHeight: " + fillHeight);
      filler.setAttribute("style", "height:"+fillHeight+"px;");
    },

    setLine: function(linenumber, content) {
      this.lazyLinesInit(linenumber);
      console.log('setLine: ' + linenumber + " (" + this.elementIndex(linenumber) + ")");
      linesElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      this.lazyLinesInit(linenumber);
      console.log('insertLine: ' + linenumber + " (" + this.elementIndex(linenumber) + ")");
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      if ((term.size.lines-1) <= linenumber) {
        linesElement.appendChild(span);
      } else {
        linesElement.insertBefore(span, linesElement.childNodes[this.elementIndex(linenumber)]);
      }
    },

    appendLine: function(content) {
      this.lazyLinesInit(term.size.lines);
      console.log("-- append line:");
      console.log(content);
      console.log("--");
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      linesElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      this.lazyLinesInit(linenumber);
      linesElement.removeChild(linesElement.childNodes[this.elementIndex(linenumber)]);
    },

    removeLastLine: function() {
      this.lazyLinesInit(term.size.lines);
      linesElement.removeChild(linesElement.lastChild);
    },

    pruneTrailingEmptyLines: function() {
      while (1) {
        if ((linesElement.childNodes.length <= term.size.lines)
            && linesElement.lastChild.textContent.match(/^ *\n/g)) { // todo: check that only the default classes are set (no cursor, no inverted-bg etc)
          console.log("pruning last child");
          linesElement.removeChild(linesElement.lastChild);
        }
      }
    },

    getSize: function() {
      return getTermSize(linesElement);
    },

    // Resize linesElement to display the given number of lines.
    // Reuse existing history to fill new lines when getting larger.
    // Like the scrolling employed by contemporary terminal emulators like
    // gnome-terminal
    resize: function(oldLines, newLines) {
      // curLines = linesElement.childNodes.length;

      // var is_empty_line = function(element) {
      //   return element && (element.tagName == 'span') && (element.innerHTML == '');
      // };

      // if (curLines < newLines) {
      //   // insert blank lines at the bottom
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     linesElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   // try to remove blank lines from the bottom
      //   linesToRemove = oldLines - newLines;
      //   while (is_empty_line(linesElement.lastChild) && (linesToRemove > 0)) {
      //     linesElement.removeChild(linesElement.lastChild);
      //     linesToRemove--;
      //   }
      // }
    },

    // clear all a lines and the history (
    reset: function() {
      console.log("reset")
      linesElement.innerHTML = "";
      // for (var i; i<lines; i++) {
      //   term.appendLine("");
      // }
      // var lines = lines || term.size.lines;
      // console.log("resetting terminal to "+lines+" lines");
      // linesElement.innerHTML = "";
      // for (var i=0; i<lines; i++) {
      //   var span = document.createElement("span");
      //   linesElement.appendChild(span);
      // }
      // term.size.lines = lines;
    },

    // iframe functions
    insertIframe: function (linenumber, id) {
      // insert an iframe 'line' before linenumber
      console.log("insert iframe line at " + linenumber);
      // close the old iframe
      if (term.currentIframe) {
        try {
          term.currentIframe.contentDocument.close();
        } catch (e) { }
      }

      this.lazyLinesInit(linenumber+1);
      var div = document.createElement('div');
      // if (term.size.lines <= linenumber) {
      //   linesElement.appendChild(div);
      // } else {
      //   console.log('insert iframe at ' + linenumber);
      //   console.log('element index: ' + this.elementIndex(linenumber));
      //   linesElement.insertBefore(div, linesElement.childNodes[this.elementIndex(linenumber)]);
      // }
      linesElement.replaceChild(div, linesElement.childNodes[this.elementIndex(linenumber)]);

      var iframe = document.createElement('iframe');
      iframe.name = id;
      iframe.id = id;
      div.appendChild(iframe);

      // provide a means to send messages to the pty
      iframe.contentWindow.schirmlog = function(msg) { console.log("frame" + id + " " + msg); };

      var newline = document.createElement('span');
      newline.innerHTML = "\n";
      div.appendChild(newline);

      term.currentIframe = iframe;

      // linemode: iframe grows vertically with content
      //           iframe is as wide as the terminal window
      iframe.height = "1";
      iframe.style.width = '100%';

      iframe.resizeHandler = function() { resizeIframe(iframe); };
      iframe.contentDocument.open("text/html");
    },

    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function (content) {
      var iframe = term.currentIframe;
      console.log('iframe_write ' + iframe);
      console.log('iframe: ' + iframe.contentDocument);
      try {
        iframe.contentDocument.write(content);
      } catch (e) {
        iframe.contentDocument.open("text/html");
        iframe.contentDocument.write(content);
      }
      resizeIframe(iframe)
    },

    // call .close on the iframe document.
    iframeCloseDocument: function() {
      var iframe = term.currentIframe;
      resizeIframe(iframe)
      try {
        iframe.contentDocument.close();
        iframe.addEventListener('load', function() { resizeIframe(iframe); });
      } catch (e) { }
    },

    // set the the current iframe document to null
    // so that we know wether were in iframe mode or not
    iframeLeave: function() {
      term.currentIframe = null;
    }

  };

  return fn;
});


// providing a character matrix without history most ncurses
// fullscreen applications seem using this, like midnight commander
var App = (function(appElement, term) {

  var fn = {

    init: function(lines) {
      linesElement.innerHTML = "";
      for (var i=0; i<lines; i++) {
         var span = document.createElement("span");
         linesElement.appendChild(span);
      }
    },

    show: function(enable) {
      appElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      return lineNumber;
    },

    scrollToBottom: function() { },

    scrollPageUp: function() { },

    scrollPageDown: function() { },

    setLine: function(linenumber, content) {
      appElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      
      if (term.size.lines <= linenumber) {
        appElement.appendChild(span);
        appElement.removeChild(appElement.firstChild);
      } else {
        appElement.insertBefore(span, appElement.childNodes[this.elementIndex(linenumber)]);
        appElement.removeChild(appElement.lastChild); // ?????
      }
    },

    appendLine: function(content) {
      appElement.removeChild(appElement.firstChild)
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      appElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      appElement.removeChild(appElement.childNodes[this.elementIndex(linenumber)]);
    },


    getSize: function() {
      return getTermSize(appElement);
    },

    // Resize the terminal space used to render the screen in
    // application mode
    resize: function(oldLines, newLines) {
      // var curLines = appElement.childNodes.length;
      // if (curLines < newLines) {
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     appElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   for (var i=0; i<(curLines-newLines); i++) {
      //     appElement.removeChild(appElement.firstChild);
      //   }
      // }
    },

    reset: function() { // todo: should take lines, cols param
      // appElement.innerHTML = "";

      // for (var i=0; i<term.size.lines; i++) {
      //   var span = document.createElement("span");
      //   appElement.appendChild(span);
      // }
    },

    // iframe
    // TODO
    // insert iframe as large as the whole screen
    // or use a second gtk webview instead - might be safer & more robust
    insertIframe: function (linenumber, id) {
      // close the old iframe
      // if (term.currentIframe) {
      //   term.currentIframe.contentDocument.close();
      // }

      // var div = document.createElement('div');
      // if (term.height <= linenumber) {
      //   linesElement.appendChild(div);
      // } else {
      //   linesElement.insertBefore(div, linesElement.childNodes[linenumber]);
      // }

      // var iframe = document.createElement('iframe');
      // div.appendChild(iframe);

      // var newline = document.createElement('span');
      // newline.innerHTML = "\n";
      // div.appendChild(newline);

      // term.currentIframe = iframe;
      // iframe.height = "1";
      // iframe.contentDocument.open("text/html");
    },

    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function(content) {
      var iframe = term.currentIframe;
      iframe.contentDocument.write(content);
    },

    iframeLeave: function(content) {
      term.currentIframe = null;
    }
  };

  return fn;

});

var Term = function() {

  var state = {
    currentIframe: undefined,
    appmode: false,
    size: { lines: 24, cols: 80 },
  };

  var lines = Lines(document.getElementById('term'), state); // one screen to render lines + history
  var app = App(document.getElementById('app'), state); // the other for rendering a char matrix w/o history

  var fn = {

    getState: function() {
      return state;
    },

    getScreen: function() {
      return state.appmode ? app : lines;
    },

    // Determine the new size of the currently active screen and return
    // it by writing JSON to console.log
    resizeHandler: function(event) {
      oldLines = state.size.lines;
      state.size = fn.getScreen().getSize();
      //fn.getScreen().resize(oldLines, state.size.lines); not required anymore
      // IPC
      console.log('schirm{"width":'+state.size.cols+',"height":'+state.size.lines+'}');
    },

    applicationMode: function(enable) {
      app.show(enable);
      lines.show(!enable);
      state.appmode = enable;
      fn.resize(state.size.lines, state.size.lines);
    },

    scrollToBottom: function() { fn.getScreen().scrollToBottom(); },
    scrollPageUp: function() { fn.getScreen().scrollPageUp(); },
    scrollPageDown: function() { fn.getScreen().scrollPageDown(); },

    setLine: function(linenumber, content) { fn.getScreen().setLine(linenumber, content); },
    insertLine: function(linenumber, content) { fn.getScreen().insertLine(linenumber, content); },
    appendLine: function(content) { fn.getScreen().appendLine(content); },
    removeLine: function(linenumber) { fn.getScreen().removeLine(linenumber); },
    removeLastLine: function() { fn.getScreen().removeLastLine(); },

    insertIframe: function (linenumber, id) { fn.getScreen().insertIframe(linenumber, id); },
    iframeWrite: function (content) { fn.getScreen().iframeWrite(content); },
    iframeCloseDocument: function() { fn.getScreen().iframeCloseDocument(); },
    iframeLeave: function() { fn.getScreen().iframeLeave(); },

    getSize: function() { return fn.getScreen().getSize(); },
    resize: function(oldLines, newLines) { fn.getScreen().resize(oldLines, newLines); },
    reset: function(lines) { fn.getScreen().reset(lines); },
    init: function(lines) { fn.getScreen().init(lines); }
  };

  return fn;
};

var term;

function termInit() {
  term = Term();
  term.init();
  term.resizeHandler();

  document.body.onresize = term.resizeHandler;
};

</script>

</head>
<body>
<pre id="term"></pre>
<div id="termTrailingSpace" style="height=0"/>
<pre id="app"></pre>
</body>
</html>

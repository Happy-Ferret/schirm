<!--
Schirm - a linux compatible terminal emulator providing html modes.
Copyright (C) 2011  Erik Soehnel

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
#termdiv {
  position: absolute;
  top:1px;
  bottom:2px;
  left:1px;
  right:2px;
}

pre {
  margin:0px;
  padding:1px;
}

iframe {
  border: None;
}

// poor man's templating system:
//TERM-CSS-PLACEHOLDER

</style>

<script type="text/javascript">

// Return the size in columns and lines of the given PRE element
function getPreSize(element) {
  var specimen = document.createElement("span");
  specimen.innerHTML = "x";
  
  element.appendChild(specimen);
  var cols  = Math.floor(element.clientWidth/specimen.offsetWidth);
  var lines = Math.floor(element.clientHeight/specimen.offsetHeight);
  //console.log("resized to [lines, cols]: [" + lines + " ," + cols + "]");
  element.removeChild(specimen);

  return { lines: lines, cols: cols }
}


// return a function which performs a resize of the given iframe
// honoring iframe.opts
function getIframeResizeHandler(iframe) {
  return function() {
    try {
      var body = iframe.contentDocument.body;
      if (body) {
        if (iframe.opts.height == 'auto') {
          iframe.height = body.scrollHeight;
        }
        if (iframe.opts.width == 'auto') {
          iframe.width = body.scrollWidth;
        }
      }
    } catch (e) {
    }
  };
}

// rendering the terminal in normal mode
// linesElement:
// a PRE element holding the terminals lines
// each line is a span of nested spans for styles
var Lines = (function(linesElement, term) {
 
  var fn = {

    init: function(lines) {
      linesElement.innerHTML = "";
      for (var i=0; i<lines; i++) {
         var span = document.createElement("span");
         linesElement.appendChild(span);
      }
    },

    show: function(enable) {
      linesElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      return linesElement.childNodes.length - term.size.lines + lineNumber;
    },
  
    scrollToBottom: function() {
      linesElement.scrollTop = linesElement.scrollHeight;
    },
  
    setLine: function(linenumber, content) {
      linesElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      if ((term.size.lines-1) <= linenumber) {
        linesElement.appendChild(span);
      } else {
        linesElement.insertBefore(span, linesElement.childNodes[this.elementIndex(linenumber)]);
      }
    },

    appendLine: function(content) {
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      linesElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      // lines 'removed' at position 0 move 'automatically' to the history
      //if (linenumber != 0) {
      //console.log("removing line number"+linenumber+" realindex:"+this.elementIndex(linenumber));
      linesElement.removeChild(linesElement.childNodes[this.elementIndex(linenumber)]);
      //}
    },

    removeLastLine: function() {
      //console.log("removing Last Line: " + linesElement.childNodes.length);
      linesElement.removeChild(linesElement.lastChild);
    },

    getSize: function() {
      return getPreSize(linesElement);
    },
    
    // Resize linesElement to display the given number of lines.
    // Reuse existing history to fill new lines when getting larger.
    // Like the scrolling employed by contemporary terminal emulators like
    // gnome-terminal
    resize: function(oldLines, newLines) {
      // curLines = linesElement.childNodes.length;

      // var is_empty_line = function(element) {
      //   return element && (element.tagName == 'span') && (element.innerHTML == '');
      // };

      // if (curLines < newLines) {
      //   // insert blank lines at the bottom
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     linesElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   // try to remove blank lines from the bottom
      //   linesToRemove = oldLines - newLines;
      //   while (is_empty_line(linesElement.lastChild) && (linesToRemove > 0)) {
      //     linesElement.removeChild(linesElement.lastChild);
      //     linesToRemove--;
      //   }
      // }
    },

    reset: function(lines) {
      linesElement.innerHtml = "";
      for (var i; i<lines; i++) {
        term.appendLine("");
      }
      // var lines = lines || term.size.lines;
      // console.log("resetting terminal to "+lines+" lines");
      // linesElement.innerHTML = "";
      // for (var i=0; i<lines; i++) {
      //   var span = document.createElement("span");
      //   linesElement.appendChild(span);
      // }
      // term.size.lines = lines;
    },

    // iframe functions
    insertIframe: function (linenumber, id, opts) {
      // insert an iframe 'line' before linenumber
      // opts are:
      //  width, height .. one of '100%' or 'auto'

      // close the old iframe
      if (term.currentIframe) {
        try {
          term.currentIframe.contentDocument.close();
        } catch (e) {
        }
      }
      
      var div = document.createElement('span');
      if (term.size.lines <= linenumber) {
        linesElement.appendChild(div);
      } else {
        linesElement.insertBefore(div, linesElement.childNodes[this.elementIndex(linenumber)]);
      }

      var iframe = document.createElement('iframe');
      iframe.name = id;
      iframe.id = id;
      div.appendChild(iframe);
      
      // provide a means to send messages to the pty
      iframe.contentWindow.schirmlog = function(msg) { console.log("frame" + id + " " + msg); };

      var newline = document.createElement('span');
      newline.innerHTML = "\n";
      div.appendChild(newline);

      term.currentIframe = iframe;

      iframe.opts = opts
      iframe.contentDocument.addEventListener('load', getIframeResizeHandler(iframe));
      if (opts.height == 'auto') {
        iframe.height = "1";
      } else if (opts.height == '100%') {
        iframe.style.height = '100%';
      }
      if (opts.width == '100%') {
        iframe.style.width = '100%';
      }

      iframe.contentDocument.open("text/html");
    },
    
    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function (content) {
      var iframe = term.currentIframe;
      try {
        iframe.contentDocument.write(content);
        this.iframeEnsureVisibility();
      } catch (e) {
        iframe.contentDocument.open("text/html");
        iframe.contentDocument.write(content);
        this.iframeEnsureVisibility();
      }
    },

    // make sure we can see at least the bottom of the current iframe
    iframeEnsureVisibility: function() {
      var iframe = term.currentIframe;
      try {
        var body = iframe.contentDocument.getElementsByTagName("body")[0];
        // body may be undefined if nothing has been written to the iframe
        if (body) {
          // don't show scrollbars on term iframes
          iframe.height = body.scrollHeight;
          // ensure the iframe is visible inside the linesElement
          if (iframe.offsetHeight < linesElement.offsetHeight) {
            // iframe is smaller than our screen
            if (iframe.offsetTop > (linesElement.offsetHeight - linesElement.offsetTop)) {
              linesElement.scrollTop = iframe.offsetTop;
            }
          } else {
            linesElement.scrollTop = iframe.offsetTop + (iframe.offsetHeight - linesElement.offsetHeight);
          }
        }
      } catch (e) {
      }
    },

    // call .close on the iframe document.
    iframeCloseDocument: function() {
      var iframe = term.currentIframe;
      try {
        iframe.addEventListener('load', getIframeResizeHandler(iframe));
        iframe.contentDocument.close();
        // Resize the iframe if its contents are modified.
        // DOMSubtreeModified is deprecated, but I haven't found a
        // better way to do this
        iframe.contentDocument.addEventListener('DOMSubtreeModified', getIframeResizeHandler(iframe));
        this.iframeEnsureVisibility();
      } catch (e) {
      }
    },

    // set the the current iframe document to null
    // so that we know wether were in iframe mode or not
    iframeLeave: function() {
      this.iframeEnsureVisibility();
      term.currentIframe = null;
    }

  };

  return fn;
});


// providing a character matrix without history most ncurses
// fullscreen applications seem using this, like midnight commander
var App = (function(appElement, term) {

  var fn = {

    init: function(lines) {
      linesElement.innerHTML = "";
      for (var i=0; i<lines; i++) {
         var span = document.createElement("span");
         linesElement.appendChild(span);
      }
    },

    show: function(enable) {
      appElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      return lineNumber;
    },
  
    scrollToBottom: function() { },
  
    setLine: function(linenumber, content) {
      appElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      if (term.size.lines <= linenumber) {
        appElement.appendChild(span);
        appElement.removeChild(appElement.firstChild);
      } else {
        appElement.insertBefore(span, appElement.childNodes[this.elementIndex(linenumber)]);
        appElement.removeChild(appElement.lastChild); // ?????
      }
    },

    appendLine: function(content) {
      appElement.removeChild(appElement.firstChild)
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      appElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      appElement.removeChild(appElement.childNodes[this.elementIndex(linenumber)]);
    },


    getSize: function() {
      return getPreSize(appElement);
    },

    // Resize the terminal space used to render the screen in
    // application mode
    resize: function(oldLines, newLines) {
      // var curLines = appElement.childNodes.length;
      // if (curLines < newLines) {
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     appElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   for (var i=0; i<(curLines-newLines); i++) {
      //     appElement.removeChild(appElement.firstChild);
      //   }
      // }
    },

    reset: function() { // todo: should take lines, cols param
      // appElement.innerHTML = "";

      // for (var i=0; i<term.size.lines; i++) {
      //   var span = document.createElement("span");
      //   appElement.appendChild(span);
      // }
    },

    // iframe
    // TODO
    // insert iframe as large as the whole screen
    // or use a second gtk webview instead - might be safer & more robust
    insertIframe: function (linenumber, id, opts) {
      // close the old iframe
      // if (term.currentIframe) {
      //   term.currentIframe.contentDocument.close();
      // }
      
      // var div = document.createElement('div');
      // if (term.height <= linenumber) {
      //   linesElement.appendChild(div);
      // } else {
      //   linesElement.insertBefore(div, linesElement.childNodes[linenumber]);
      // }

      // var iframe = document.createElement('iframe');
      // div.appendChild(iframe);
      
      // var newline = document.createElement('span');
      // newline.innerHTML = "\n";
      // div.appendChild(newline);
      
      // term.currentIframe = iframe;
      // iframe.height = "1";
      // iframe.contentDocument.open("text/html");
    },
    
    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function(content) {
      var iframe = term.currentIframe;
      iframe.contentDocument.write(content);
    },

    iframeLeave: function(content) {
      term.currentIframe = null;
    }
  };

  return fn;

});

var Term = function() {

  var state = {
    currentIframe: undefined,
    appmode: false,
    size: { lines: 24, cols: 80 },  
  };

  var termdiv = document.getElementById('termdiv');
  var lines = Lines(document.getElementById('term'), state); // one screen to render lines + history
  var app = App(document.getElementById('app'), state); // the other for rendering a char matrix w/o history
  
  var fn = {
    
    getState: function() {
      return state;
    },

    getScreen: function() {
      return state.appmode ? app : lines;
    },

    // Determine the new size of the currently active screen and return
    // it by writing JSON to console.log
    resizeHandler: function(event) {
      oldLines = state.size.lines;
      state.size = fn.getScreen().getSize();
      //fn.getScreen().resize(oldLines, state.size.lines); not required anymore
      // IPC
      console.log('schirm{"width":'+state.size.cols+',"height":'+state.size.lines+'}');
    },

    applicationMode: function(enable) {
      app.show(enable);
      lines.show(!enable);
      state.appmode = enable;
      fn.resize(state.size.lines, state.size.lines);
    },

    scrollToBottom: function() { fn.getScreen().scrollToBottom(); },

    setLine: function(linenumber, content) { fn.getScreen().setLine(linenumber, content); },
    insertLine: function(linenumber, content) { fn.getScreen().insertLine(linenumber, content); },
    appendLine: function(content) { fn.getScreen().appendLine(content); },
    removeLine: function(linenumber) { fn.getScreen().removeLine(linenumber); },
    removeLastLine: function() { fn.getScreen().removeLastLine(); },

    insertIframe: function (linenumber, id, opts) { fn.getScreen().insertIframe(linenumber, id, opts); },
    iframeWrite: function (content) { fn.getScreen().iframeWrite(content); },
    iframeCloseDocument: function() { fn.getScreen().iframeCloseDocument(); },
    iframeLeave: function() { fn.getScreen().iframeLeave(); },

    getSize: function() { return fn.getScreen().getSize(); },
    resize: function(oldLines, newLines) { fn.getScreen().resize(oldLines, newLines); },
    reset: function(lines) { fn.getScreen().reset(lines); },
    init: function(lines) { fn.getScreen().init(lines); }
  };
  
  return fn;
};

var term;

function termInit() {
  term = Term();
  term.init(80);
  term.resizeHandler();

  document.body.onresize = term.resizeHandler;
};

</script>

</head>
<body>
<div id="termdiv"><pre id="term" style="overflow-y:scroll;overflow-x:visible;width:100%;height:100%;"></pre><pre id="app" style="overflow:hide;display:none;width:100%;height:100%;"></pre></div>
</body>
</html>

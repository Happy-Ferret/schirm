<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" href="term.css" type="text/css">
<!--<script type="text/javascript" src="jquery-1.6.2.js">-->
<!--<script type="text/javascript" src="term.js">-->
<style type="text/css">
#termdiv {
  position: absolute;
  top:0px;
  bottom:0px;
  left:0px;
  right:0px;
}

pre {
  margin:0px;
}

iframe {
  border: None;
  width: 100%;
}

</style>

<script type="text/javascript">


// Return the size in columns and lines of the given PRE element
function getPreSize(element) {
  var specimen = document.createElement("span");
  specimen.innerHTML = "x";
  
  element.appendChild(specimen);
  var cols  = Math.floor(element.clientWidth/specimen.offsetWidth);
  var lines = Math.floor(element.clientHeight/specimen.offsetHeight);
  //console.log("resized to [lines, cols]: [" + lines + " ," + cols + "]");
  element.removeChild(specimen);

  return { lines: lines, cols: cols }
}


// rendering the terminal in normal mode
// linesElement:
// a PRE element holding the terminals lines
// each line is a span of nested spans for styles
var Lines = (function(linesElement, term) {
 
  var fn = {
    show: function(enable) {
      linesElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      return linesElement.childNodes.length - term.size.lines + lineNumber;
    },
  
    scrollToBottom: function() {
      linesElement.scrollTop = linesElement.scrollHeight;
    },
  
    setLine: function(linenumber, content) {
      linesElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      if ((term.size.lines-1) <= linenumber) {
        linesElement.appendChild(span);
      } else {
        linesElement.insertBefore(span, linesElement.childNodes[this.elementIndex(linenumber)]);
      }
    },

    appendLine: function(content) {
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      linesElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      // lines 'removed' at position 0 move 'automatically' to the history
      //if (linenumber != 0) {
      //console.log("removing line number"+linenumber+" realindex:"+this.elementIndex(linenumber));
      linesElement.removeChild(linesElement.childNodes[this.elementIndex(linenumber)]);
      //}
    },

    removeLastLine: function() {
      //console.log("removing Last Line: " + linesElement.childNodes.length);
      linesElement.removeChild(linesElement.lastChild);
    },

    // iframe
    insertIframe: function (linenumber) {
      // close the old iframe
      if (term.currentIframe) {
        term.currentIframe.contentDocument.close();
      }
      
      var div = document.createElement('span');
      div.setAttribute("foobar");
      if (term.size.lines <= linenumber) {
        linesElement.appendChild(div);
      } else {
        linesElement.insertBefore(div, linesElement.childNodes[this.elementIndex(linenumber)]);
      }

      var iframe = document.createElement('iframe');
      div.appendChild(iframe);
      
      var newline = document.createElement('span');
      newline.innerHTML = "\n";
      div.appendChild(newline);
      
      term.currentIframe = iframe;
      iframe.height = "1";
      iframe.contentDocument.open("text/html");
    },
    
    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function (content) {
      var iframe = term.currentIframe;
      iframe.contentDocument.write(content);
      var body = iframe.contentDocument.getElementsByTagName("body")[0];
      if (body) {
        // body may be undefined if nothing has been written to the iframe
        iframe.height = body.scrollHeight;
      }
    },

    getSize: function() {
      return getPreSize(linesElement);
    },
    
    // Resize linesElement to display the given number of lines.
    // Reuse existing history to fill new lines when getting larger.
    // Like the scrolling employed by contemporary terminal emulators like
    // gnome-terminal
    resize: function(oldLines, newLines) {
      // curLines = linesElement.childNodes.length;

      // var is_empty_line = function(element) {
      //   return element && (element.tagName == 'span') && (element.innerHTML == '');
      // };

      // if (curLines < newLines) {
      //   // insert blank lines at the bottom
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     linesElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   // try to remove blank lines from the bottom
      //   linesToRemove = oldLines - newLines;
      //   while (is_empty_line(linesElement.lastChild) && (linesToRemove > 0)) {
      //     linesElement.removeChild(linesElement.lastChild);
      //     linesToRemove--;
      //   }
      // }
    },

    reset: function(lines) {
      // var lines = lines || term.size.lines;
      // console.log("resetting terminal to "+lines+" lines");
      // linesElement.innerHTML = "";
      // for (var i=0; i<lines; i++) {
      //   var span = document.createElement("span");
      //   linesElement.appendChild(span);
      // }
      // term.size.lines = lines;
    },

    init: function(lines) {
      linesElement.innerHTML = "";
      for (var i=0; i<lines; i++) {
         var span = document.createElement("span");
         linesElement.appendChild(span);
      }
    }
  };

  return fn;
});


// providing a character matrix without history most ncurses
// fullscreen applications seem using this, like midnight commander
var App = (function(appElement, term) {

  var fn = {

    show: function(enable) {
      appElement.style.display = enable ? "block" : "none";
    },

    elementIndex: function(lineNumber) {
      return lineNumber;
    },
  
    scrollToBottom: function() { },
  
    setLine: function(linenumber, content) {
      appElement.childNodes[this.elementIndex(linenumber)].innerHTML = content + "\n";
    },

    insertLine: function(linenumber, content) {
      var span = document.createElement('span');
      span.innerHTML = content + "\n";
      if (term.size.lines <= linenumber) {
        appElement.appendChild(span);
        appElement.removeChild(appElement.firstChild);
      } else {
        appElement.insertBefore(span, appElement.childNodes[this.elementIndex(linenumber)]);
        appElement.removeChild(appElement.lastChild); // ?????
      }
    },

    appendLine: function(content) {
      appElement.removeChild(appElement.firstChild)
      var span = document.createElement("span");
      span.innerHTML = content + "\n";
      appElement.appendChild(span);
    },

    removeLine: function(linenumber) {
      appElement.removeChild(appElement.childNodes[this.elementIndex(linenumber)]);
    },

    // TODO
    // insert iframe as large as the whole screen
    // or use a second gtk webview instead - might be safer & more robust
    insertIframe: function (linenumber) {
      // close the old iframe
      // if (term.currentIframe) {
      //   term.currentIframe.contentDocument.close();
      // }
      
      // var div = document.createElement('div');
      // if (term.height <= linenumber) {
      //   linesElement.appendChild(div);
      // } else {
      //   linesElement.insertBefore(div, linesElement.childNodes[linenumber]);
      // }

      // var iframe = document.createElement('iframe');
      // div.appendChild(iframe);
      
      // var newline = document.createElement('span');
      // newline.innerHTML = "\n";
      // div.appendChild(newline);
      
      // term.currentIframe = iframe;
      // iframe.height = "1";
      // iframe.contentDocument.open("text/html");
    },
    
    // contentDocument.write content (a string) to the currentIframe and
    // resize it (vertically) if necessary
    iframeWrite: function (content) {
      var iframe = term.currentIframe;
      iframe.contentDocument.write(content);
    },

    getSize: function() {
      return getPreSize(appElement);
    },

    // Resize the terminal space used to render the screen in
    // application mode
    resize: function(oldLines, newLines) {
      // var curLines = appElement.childNodes.length;
      // if (curLines < newLines) {
      //   for (var i=0; i<(newLines-curLines); i++) {
      //     appElement.appendChild(document.createElement('span'));
      //   }
      // } else {
      //   for (var i=0; i<(curLines-newLines); i++) {
      //     appElement.removeChild(appElement.firstChild);
      //   }
      // }
    },

    reset: function() { // todo: should take lines, cols param
      // appElement.innerHTML = "";

      // for (var i=0; i<term.size.lines; i++) {
      //   var span = document.createElement("span");
      //   appElement.appendChild(span);
      // }
    },

    init: function(lines) {
      linesElement.innerHTML = "";
      for (var i=0; i<lines; i++) {
         var span = document.createElement("span");
         linesElement.appendChild(span);
      }
    }
  };

  return fn;

});

var Term = function() {

  var state = {
    currentIframe: undefined,
    appmode: false,
    size: { lines: 24, cols: 80 },  
  };

  var termdiv = document.getElementById('termdiv');
  var lines = Lines(document.getElementById('term'), state); // one screen to render lines + history
  var app = App(document.getElementById('app'), state); // the other for rendering a char matrix w/o history
  
  var fn = {
    
    getState: function() {
      return state;
    },

    getScreen: function() {
      return state.appmode ? app : lines;
    },

    // Determine the new size of the currently active screen and return
    // it by writing JSON to console.log
    resizeHandler: function(event) {
      oldLines = state.size.lines;
      state.size = fn.getScreen().getSize();
      //fn.getScreen().resize(oldLines, state.size.lines); not required anymore
      // IPC
      console.log('schirm{"width":'+state.size.cols+',"height":'+state.size.lines+'}');
    },

    applicationMode: function(enable) {
      app.show(enable);
      lines.show(!enable);
      state.appmode = enable;
      fn.resize(state.size.lines, state.size.lines);
    },

    scrollToBottom: function() { fn.getScreen().scrollToBottom(); },

    setLine: function(linenumber, content) { fn.getScreen().setLine(linenumber, content); },
    insertLine: function(linenumber, content) { fn.getScreen().insertLine(linenumber, content); },
    appendLine: function(content) { fn.getScreen().appendLine(content); },
    removeLine: function(linenumber) { fn.getScreen().removeLine(linenumber); },
    removeLastLine: function() { fn.getScreen().removeLastLine(); },

    insertIframe: function (linenumber) { fn.getScreen().insertIframe(linenumber); },
    iframeWrite: function (content) { fn.getScreen().iframeWrite(content); },

    getSize: function() { return fn.getScreen().getSize(); },
    resize: function(oldLines, newLines) { fn.getScreen().resize(oldLines, newLines); },
    reset: function(lines) { fn.getScreen().reset(lines); },
    init: function(lines) { fn.getScreen().init(lines); }
  };
  
  return fn;
};


var term;

function termInit() {
  term = Term();
  term.init(80);
  term.resizeHandler();

  document.body.onresize = term.resizeHandler;
};

</script>

</head>
<body>
<div id="termdiv"><pre id="term" style="overflow-y:scroll;overflow-x:hide;width:100%;height:100%;"></pre><pre id="app" style="overflow:hide;display:none;width:100%;height:100%;"></pre></div>
</body>
</html>
